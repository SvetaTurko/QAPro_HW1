'number' + 3 + 3 /*відповідь "number33", робимо конкатинацію і все стає строкою */

null + 3 /*відповідь 3, тому що null приводимо до цифр, оскільки null=0 тоді, 0+3=3 */

5 && "qwerty" /* відповідь "qwerty", тому що && в цьому випадку поверне останній операнд, тому що всі операнди правдиві*/

+'40' + +'2' + "hillel"; /* відповідь 42hillel, тому що унарний плюс приводить до числа, значить строка "40" стає числом 40, те саме з "2", між ними є математчна операція додавання, тому 42,
дальше йде конкатинація рядка */

'10' - 5 === 6;  /*відповідь false, тому що 10-5=5, і 5===6 => false */

true + false  /* відповідь 1, бо переводимо у цифри булінові значення 1+0=1 */

'4px' - 3   /*відповідь NaN */ 

'4' - 3     /* відповідь 1, строку "4" переводисо у число і робимо віднімання між двома цифрами   */ 

'6' + 3 ** 0;  /* відповідь 61, тому що спочатку по пріоритету обчислюємо вираз зі степеню, будь-яке число у степенi 0 дорiвнює 1, значить 3**0=1, 
дальше робимо конкатинацію "6" і 1 = 61 і це строка*/ 

12 / '6'  /* відповідь 2, тому що ділення приводить до чисел, значить 12/6=2  */

'10' + (5 === 6);  /* відповідь 10false, тому що 5===6 має значення false , дальше йде конкатинація і це буде строка*/

null == ''  /* відповідь false, тому що порожній радок буде false, а null == false буде мати false. Але я не впевнена  */

3 ** (9 / 3);  /* відповідь 27, ми спочатку ділимо 9 на 3, і потім піднімаємо трійку у 3-тю степінь*/

!!'false' == !!'true' /* відповідь true, !! перетворює значення у булен, значить стрінги 'false'  та 'true' ми перетворюємо у буленові значення 1 */ 

0 || '0' && 1   /* відповідь 1, тому що && (і) має більший пріоритет ніж || (або), тому спочатку дивимося на частину приклада '0' && 1, і його рішення буде 1, тому що всі значення 
є правдимиви і вертаємо останнє правдиве значення 1. потім порівнюємо 0 || 1 , і тут перше правдиве значення буде 1 */

(+null == false) < 1; /* відповідь false*/

false && true || true /* відповідь true, спочатку дивимося на вираз false && true, що повертає false, і потім дивимося на false || true, що поверне тру, бо вираз або*/

false && (false || true);  /* відповідь false */

(+null == false) <  1 ** 5;  /* відповідь false, тому що +null переводимо у білінове значення, оскільки це null це false, а false==false => true (а тру це 1), обчислюємо
праву частину виразу, 1 у 5 степені буде 1, а вираз 1<1 є не правдивий, тому  false */
